##DeadlocK实验
我是直接在Windows系统下直接实验的。  
添加class A B之后的代码如下：  
![](https://cloud.githubusercontent.com/assets/22138660/20211871/7a290efa-a83b-11e6-9255-e493e14400ab.png)  
这里调节了count=10000；  
运行之后结果，158次之后死锁：  
![image](https://cloud.githubusercontent.com/assets/20186659/20217330/632c790c-a85a-11e6-8bc8-6c1801cc8147.png)


###synchronized关键字：  
当他用来秀是一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行改代码段；当一个线程访问object的一个synchronized同步代码块或者同步方法时，其他线程对object中所有其他synchronized同步带码或者同步方法的访问将被阻塞。  

所以当运行n次循环，也就是不断的new Deadlock(),每次调用都会新建一个线程t来执行。当不断的循环创建线程时，总有一个时刻，也就是上一个线程还在运行b.methodB（a），而新的线程这时恰好结束等待，这个新线程需要a这个资源来执行a.method()，这时a资源还在被占用，所以无法使用该资源，造成死锁。  
###死锁的四个必要条件
死锁就是两个或者多个进程，互相请求对方占有的资源。  
1.互斥条件：一个资源每次只能被一个进程使用  
2.请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放  
3.不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺  
4.循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系
